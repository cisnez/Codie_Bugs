**Also, if you're interested in more advanced programming patterns, you could consider looking into the observer pattern or the publish-subscribe pattern, both of which are widely used in event-driven programming.**

User
You are an exper python programmer.

Project: Develop a learning path for Python: listeners, messages, events, sentinels, and triggers.

**Current status:**
1. When an alien reaches the player it is removed from the screen.
    All the aliens hit the player and are removed.
        The game never ends and a new level never starts.

**Return code and explaination to fix the issue.**

Game launch point.
```#G4M3.py
# Game Class: This class would manage the overall game, including creating and managing all the game objects, handling user input, and updating the game state.
# Note 1: This Game class has a Sentinel as an attribute. It creates a new Sentinel when a level starts and defines the condition that must be met for the play to end.

# The event processing loop is located in the run method of the G4M3 class:

import time

from B453Object import B453Object
from G4M3Object import G4M3Object
from EN717135.AL13N import AL13N
from EN717135.BULL37 import BULL37
from EN717135.PL4Y3R import PL4Y3R
from TR1663R.S3N71N3L import S3N71N3L
from TR1663R.EV3N7 import EV3N7

class G4M3(B453Object):
    def __init__(self):
        super().__init__()
        pygame.init()
        self.game_over = False
        self.screen = pygame.display.set_mode((800, 600))  
        self.aliens = []
        self.bullets = []
        self.player = PL4Y3R((800 - 50) / 2, 600 - 50)
        self.player_speed = 15
        self.alien_direction = -1  
        self.level_end_sentinel = None
        
    def start_level(self):
        print("You are starting a level!\nGet ready for the next push!")
        self.bullets = []
        self.aliens = []
        for row in range(5):
            for col in range(10):
                self.aliens.append(AL13N(col * 60 + 50, row * 60 + 50)) 
        self.level_end_sentinel = S3N71N3L(self.player, self.aliens)
        self.level_end_sentinel.add_listener('game_over', self)
        self.level_end_sentinel.add_listener('level_end', self)

    def handle_event(self, event):
        event_type = event.get_type()
        if event_type == 'life_lost':
            print("A life was lost!")
            # Start the same level again
            self.start_level()
        elif event_type == 'game_over':
            print("Game over!")
            self.game_over = True
            # Additional game over logic here
        elif event_type == 'level_end':
            print("Next level!")
            # Start the next level
            self.start_level()
        elif event_type == 'alien_hit':
            print("Alien was hit!")
            # Implement your 'alien_hit' logic here
            pass  
        elif event_type == 'power_up':
            print("Power up!")
            # Implement your 'power_up' logic here
            pass
        elif event_type == 'bullet_fired':
            print("Bullet fired!")
            # Implement your 'bullet_fired' logic here
            pass
        elif event_type == 'player_move':
            print("Player moved!")
            # Implement your 'player_move' logic here
            pass
        # add any other events as needed
        # elif event == 'another_event':
        #     do_something()

    def run(self):
        while not self.game_over:
            keys = pygame.key.get_pressed() 
            if keys[pygame.K_a] or keys[pygame.K_LEFT]:  
                self.player.move(-self.player_speed, 0)
            if keys[pygame.K_d] or keys[pygame.K_RIGHT]: 
                self.player.move(self.player_speed, 0)
            if keys[pygame.K_SPACE] or keys[pygame.K_w] or keys[pygame.K_UP]:
                self.player.should_shoot()
            for event in pygame.event.get():  
                if event.type == pygame.QUIT:  
                    return
            self.update_game_state()
            self.draw_game_state()
            self.level_end_sentinel.check_condition()
            time.sleep(0.1)

    def update_game_state(self):
        self.player.move(0, 0) 
        new_bullet = self.player.shoot()
        if new_bullet is not None:
            self.bullets.append(new_bullet)
        if self.aliens:
            rightmost_alien_x = max(alien.x for alien in self.aliens)
            leftmost_alien_x = min(alien.x for alien in self.aliens)
            if rightmost_alien_x + self.aliens[0].speed > 800 or leftmost_alien_x - self.aliens[0].speed < 0:
                self.alien_direction *= -1
                for alien in self.aliens:
                    alien.y += alien.down_speed
            for alien in self.aliens:
                alien.move(self.alien_direction)
                if alien.y >= self.player.y:
                    self.aliens.remove(alien)
                    self.player.decrease_lives()
        for bullet in self.bullets:
            bullet.move()
            for alien in self.aliens:
                if bullet.collides_with(alien):
                    self.bullets.remove(bullet)
                    self.aliens.remove(alien)
                    break

    def draw_game_state(self):
        self.screen.fill((0, 0, 0)) 
        pygame.draw.rect(self.screen, (255, 255, 255), pygame.Rect(self.player.x, self.player.y, 50, 50))  
        for alien in self.aliens:
            pygame.draw.circle(self.screen, (0, 255, 0), (alien.x, alien.y), alien.radius)
        for bullet in self.bullets:
            pygame.draw.rect(self.screen, (255, 0, 0), pygame.Rect(bullet.x, bullet.y, bullet.width, bullet.height))
        pygame.display.flip()  

if __name__ == '__main__':
    try:
        game = G4M3()
        game.start_level()
        game.run()
    finally:
        pygame.quit()
```

```
#G4M3Object.py
# Game Object Class: This class will extend the Base Object and will be the parent class for all the actual game entities like Player, Alien, and Bullet.

from B453Object import B453Object

class G4M3Object(B453Object):
    def __init__(self, x, y):
        super().__init__(x, y)
```

```
#B453Object.py
# Base Object Class: This will be the parent class for all game objects. It will contain listeners and methods to add, remove, and trigger events.

class B453Object:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
        self.listeners = []

    def add_listener(self, listener):
        self.listeners.append(listener)

    def remove_listener(self, listener):
        self.listeners.remove(listener)

    def trigger_event(self, event):
        for listener in self.listeners:
            listener.handle_event(event)
```

```
#EV3N7.py
# Event Class: This class extends the BaseObject class and acts as a trigger safety. It checks whether certain conditions are met before triggering its event.

class EV3N7:
    def __init__(self, event_type, data):
        self.event_type = event_type
        self.data = data

    def get_type(self):
        return self.event_type

    def get_data(self):
        return self.data
```

```
#S3N71N3L.py
# Sentinel Class: This class extends the BaseObject class and acts as a trigger safety. It checks whether certain conditions are met before triggering its event.

from B453Object import B453Object
from TR1663R.EV3N7 import EV3N7

class S3N71N3L(B453Object):
    def __init__(self, player, aliens):
        super().__init__()
        self.player = player
        self.aliens = aliens

    def check_condition(self):
        if any(alien.has_reached_bottom() for alien in self.aliens):
            raise Exception("We have :codie_bug:'s!")
        elif any(alien.y >= self.player.y for alien in self.aliens): 
            # This will trigger 'life_lost' or 'game_over' event
            self.player.decrease_lives()
            if self.player.lives == 0: 
                self.trigger_event(EV3N7('game_over', {}))
        elif all(alien.all_aliens_eliminated() for alien in self.aliens):
            self.trigger_event(EV3N7('level_end', {}))
        elif self.player.lives == 0: 
            self.trigger_event(EV3N7('game_over', {}))
        elif self.player.all_your_base_r_belong_2_us():
            self.trigger_event(EV3N7('game_over', {}))
```

```
#AL13N.py
# Alien Class:

from G4M3Object import G4M3Object

class AL13N(G4M3Object):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.radius = 20 
        self.direction = 1
        self.speed = 20
        self.down_speed = 20

    def move(self, direction):
        self.x += self.speed * direction

    def has_reached_bottom(self):
        return self.y > 600
```

```
#BULL37.py
# Bullet Class:

from G4M3Object import G4M3Object

class BULL37(G4M3Object):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.width = 5
        self.height = 10

    def move(self):
        self.y -= 5

    def collides_with(self, alien):
        distance = ((self.x - alien.x)**2 + (self.y - alien.y)**2)**0.5
        return distance <= alien.radius
```

```
#PL4Y3R.py
# Player Class:

from G4M3Object import G4M3Object
from EN717135.BULL37 import BULL37

class PL4Y3R(G4M3Object):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.shoot_bullet = False
        self.lives = 3 

    def decrease_lives(self):
        self.lives -= 1
        if self.lives == 0:
            self.trigger_event(EV3N7('game_over', {}))
        else:
            self.trigger_event(EV3N7('life_lost', {}))

    def move(self, dx, dy):
        self.x = (self.x + dx) % 800
        self.y = (self.y + dy) % 600

    def shoot(self):
        if self.shoot_bullet:
            self.shoot_bullet = False
            return BULL37(self.x, self.y)
        else:
            return None

    def should_shoot(self):
        self.shoot_bullet = True

    def all_your_base_r_belong_2_us(self):
        return self.x <= 0 or self.x >= 800
```