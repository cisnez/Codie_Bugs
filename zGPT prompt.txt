Project: Learning Python listeners, messages, events, sentinels, and triggers.

User:
Current status:
1. The aliens reach the bottom of the display surface and game crashes with expected exception error.
2. Console streams the message `Game Over` when the player moves off the left or right side of the screen.
3. When an alien reaches the player the console streams the message `Game over!`.

Return code and explaination for following changes.
1. When the aliens reach the player, the player is to lose a life or game over if last life.
2. When player goes off the screen they enter from the other side of the screen instead of `Game Over` message.
3. When the aliens reach the player a life is lost.
4. The level starts over if a life is lost.
4. The game ends if there are no more lives.

Game launch point.
```#G4M3.py
import time
import pygame

from B453Object import B453Object
from G4M3Object import G4M3Object
from EN717135.AL13N import AL13N
from EN717135.BULL37 import BULL37
from EN717135.PL4Y3R import PL4Y3R
from TR1663R.S3N71N3L import S3N71N3L

class G4M3(B453Object):
    def __init__(self):
        super().__init__()
        pygame.init()
        self.screen = pygame.display.set_mode((800, 600))  
        self.aliens = []
        self.bullets = []
        self.player = PL4Y3R((800 - 50) / 2, 600 - 50)
        self.alien_direction = -1  
        self.level_end_sentinel = None
        
    def start_new_level(self):
        print("You eliminated all the codie bugs!\nGet ready for the next push!")
        self.bullets = []
        self.aliens = []
        for row in range(5):
            for col in range(10):
                # Spacing aliens by 60 pixels and offsetting them by 50 pixels from the edge
                self.aliens.append(AL13N(col * 60 + 50, row * 60 + 50)) 
        self.level_end_sentinel = S3N71N3L(self.player, self.aliens)
        self.level_end_sentinel.add_listener(self)

    def handle_event(self, event):
        if event == 'level_end':
            print("Level completed!")
            self.start_new_level() 
        elif event == 'game_over':
            print("Game over!")
            # Additional game over logic here

    def run(self):
        while True:
            for event in pygame.event.get():  # Process system events
                if event.type == pygame.QUIT:  # The 'X' button was clicked
                    return
                # This will keep your window responsive and also allow you to close the window by clicking the 'X' button.
            self.update_game_state()
            self.draw_game_state()
            self.level_end_sentinel.check_condition()
            time.sleep(0.1)

def update_game_state(self):
    self.player.move(0, 0) 
    new_bullet = self.player.shoot()
    if new_bullet is not None:
        self.bullets.append(new_bullet)
    if self.aliens:
        rightmost_alien_x = max(alien.x for alien in self.aliens)
        leftmost_alien_x = min(alien.x for alien in self.aliens)
        if rightmost_alien_x + self.aliens[0].speed > 800 or leftmost_alien_x - self.aliens[0].speed < 0:
            self.alien_direction *= -1
            for alien in self.aliens:
                alien.y += alien.down_speed
        for alien in self.aliens:
            alien.move(self.alien_direction)
            # Alien has reached the player
            if alien.y >= self.player.y:
                # Decrease player's lives
                self.player.decrease_lives()
    for bullet in self.bullets:
        bullet.move()
        for alien in self.aliens:
            if bullet.collides_with(alien):
                self.bullets.remove(bullet)
                self.aliens.remove(alien)
                break

    def draw_game_state(self):
        self.screen.fill((0, 0, 0)) 
        pygame.draw.rect(self.screen, (255, 255, 255), pygame.Rect(self.player.x, self.player.y, 50, 50))  
        for alien in self.aliens:
            pygame.draw.circle(self.screen, (0, 255, 0), (alien.x, alien.y), alien.radius)
        for bullet in self.bullets:
            pygame.draw.rect(self.screen, (255, 0, 0), pygame.Rect(bullet.x, bullet.y, bullet.width, bullet.height)) 
        pygame.display.flip()  

if __name__ == '__main__':
    try:
        game = G4M3()
        game.start_new_level()
        game.run()
    finally:
        pygame.quit()
```

```
#G4M3Object.py
# Game Object Class: This class will extend BaseObject and will be the parent class for all the actual game entities like Player, Alien, and Bullet.

from B453Object import B453Object

class G4M3Object(B453Object):
    def __init__(self, x, y):
        super().__init__(x, y)
```

```
#B453Object.py
# Base Object Class: This will be the parent class for all game objects. It will contain listeners and methods to add, remove, and trigger events.

class B453Object:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
        self.listeners = []

    def add_listener(self, listener):
        self.listeners.append(listener)

    def remove_listener(self, listener):
        self.listeners.remove(listener)

    def trigger_event(self, event):
        for listener in self.listeners:
            listener.handle_event(event)
```

```
#S3N71N3L.py
# Sentinel Class: This class extends the BaseObject class and acts as a trigger safety. It checks whether certain conditions are met before triggering its event.

from B453Object import B453Object

class S3N71N3L(B453Object):
    def __init__(self, player, aliens):
        super().__init__()
        self.player = player
        self.aliens = aliens

    def check_condition(self):
        # Check if Alien :codie_bug: has landed.
        if any(alien.has_reached_bottom() for alien in self.aliens):
            raise Exception("We have :codie_bug:'s!")
        # Check if all Alien :codie_bug:'s have been eliminated
        elif all(alien.all_aliens_eliminated() for alien in self.aliens):
            self.trigger_event('level_end')
        # Check if any Alien :codie_bug: has reached the player
        elif any(alien.y >= self.player.y for alien in self.aliens): 
            self.trigger_event('game_over')
        # Check if Player has retreated off of the screen.
        elif self.player.all_your_base_r_belong_2_us():
            self.trigger_event('game_over')
```

```
#AL13N.py
# Alien Class:

from G4M3Object import G4M3Object

class AL13N(G4M3Object):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.radius = 20  # Add a radius attribute for drawing the circle
        self.direction = 1  # Aliens start moving to the right
        self.speed = 10  # Adjust to control the speed of the aliens
        self.down_speed = 10  # Adjust to control how much the aliens move down after hitting a wall

    def move(self, direction):
        self.x += self.speed * direction

    # Check if the alien has reached the bottom of the screen
    def has_reached_bottom(self):
        return self.y > 600
    
    # Check if there are any alien objects above the bottom of the display surface
    def all_aliens_eliminated(self):
        return self.y > 600
```

```
#BULL37.py
# Bullet Class:

from G4M3Object import G4M3Object

class BULL37(G4M3Object):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.width = 5  # Add a width attribute for drawing the rectangle
        self.height = 10  # Add a height attribute for drawing the rectangle

    def move(self):
        self.y -= 5  # Bullets move up the screen

    def collides_with(self, alien):
        # Check if the distance between the bullet's center and the alien's center is less than or equal to the alien's radius.
        distance = ((self.x - alien.x)**2 + (self.y - alien.y)**2)**0.5
        return distance <= alien.radius
```

```
#PL4Y3R.py
# Player Class:

from G4M3Object import G4M3Object
from EN717135.BULL37 import BULL37

class PL4Y3R(G4M3Object):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.shoot_bullet = False
        # Player starts with 3 lives
        self.lives = 3 

    def decrease_lives(self):
        self.lives -= 1
        if self.lives == 0:
            self.trigger_event('game_over')

    def move(self, dx, dy):
        self.x += dx
        self.y += dy

    def shoot(self):
        if self.shoot_bullet:
            self.shoot_bullet = False
            # Return a new bullet instance that starts at the player's current location
            return BULL37(self.x, self.y)
        else:
            return None

    def should_shoot(self):
        self.shoot_bullet = True

    # check whether the player has moved off the right side of the screen.
    def all_your_base_r_belong_2_us(self):
        return self.x <= 0 or self.x >= 800
```