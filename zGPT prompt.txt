User
You are an exper python programmer.

Project: Develop a learning path for Python: listeners, messages, events, sentinels, and triggers.

The original design goals mention:
    "To process these events, you need to call pygame.event.pump() or pygame.event.get() regularly."
1. What is event.pump?
2. Why did we choose to only use event.get?

**Current status:**
1. I found a strange bug. Player speed is not behaving consistently.
    a. If the player speed is set to 5 and the player hits the wall the Game Over event is triggered.
    b. If the player speed is set to 20 then the player teleports to the opposite side of the screen.
2. When an alien reaches the player nothing happens on the console and the game keeps going until exception error since lose a life or game over isn't working.
3. As expected since #2 doesn't work the aliens reach the bottom of the display surface and the game crashes with the expected exception error. This needs to remain as this situation should never happen.
4. We created a base object method to remove_listener and we never use it. Our sentinel does add_listener and never remove_listener. Would it be best to 


**Return code and explaination for following changes.**
1. When the aliens reach the player, the player is to lose a life or game over if last life.
2. When player goes off the screen they enter from the other side of the screen instead of `Game Over` message no matter how slow or fast the player is moving. Currently the game is over if the player speed is set to slow value.
3. When the aliens reach the player a life is to be lost.
4. The game ends if there are no more lives.
5. The level starts over if a life is lost.
6. Keep the exception error and avoid it by coding 1-5 properly.
7. Have the sentinel `try` check_condition, if any are caught then, remove_listener, and do what we need to do. Am I right to believe that all the check_conditions are going to result in spawning a new sentinel?   

Game launch point.
```#G4M3.py
# Game Class: This class would manage the overall game, including creating and managing all the game objects, handling user input, and updating the game state.
# Note 1: This Game class has a Sentinel as an attribute. It creates a new Sentinel when a level starts and defines the condition that must be met for the play to end.

# The event processing loop is located in the run method of the G4M3 class:

import time

from B453Object import B453Object
from G4M3Object import G4M3Object
from EN717135.AL13N import AL13N
from EN717135.BULL37 import BULL37
from EN717135.PL4Y3R import PL4Y3R
from TR1663R.S3N71N3L import S3N71N3L

class G4M3(B453Object):
    def __init__(self):
        super().__init__()
        pygame.init()

        self.game_over = False

        self.screen = pygame.display.set_mode((800, 600))  

        self.aliens = []
        self.bullets = []

        self.player = PL4Y3R((800 - 50) / 2, 600 - 50)
        self.player_speed = 5

        self.alien_direction = -1  

        self.level_end_sentinel = None
        
    def start_level(self):
        print("You are starting a level!\nGet ready for the next push!")
        self.bullets = []
        self.aliens = []
        for row in range(5):
            for col in range(10):
                self.aliens.append(AL13N(col * 60 + 50, row * 60 + 50)) 
        
        self.level_end_sentinel = S3N71N3L(self.player, self.aliens)
        self.level_end_sentinel.add_listener(self)

    def handle_event(self, event):
        if event == 'life_lost':
            print("A life was lost!")
            # Start the same level again
            self.start_level()
        elif event == 'game_over':
            print("Game over!")
            self.game_over = True
            # Additional game over logic here
        elif event == 'next_level':
            print("Next level!")
            # Start the next level
            self.start_level()
        elif event == 'alien_hit':
            print("Alien was hit!")
            # Implement your 'alien_hit' logic here
            pass  
        elif event == 'power_up':
            print("Power up!")
            # Implement your 'power_up' logic here
            pass
        elif event == 'bullet_fired':
            print("Bullet fired!")
            # Implement your 'bullet_fired' logic here
            pass
        elif event == 'player_move':
            print("Player moved!")
            # Implement your 'player_move' logic here
            pass
        # add any other events as needed
        # elif event == 'another_event':
        #     do_something()

    def run(self):
        while not self.game_over:
            keys = pygame.key.get_pressed() 
            if keys[pygame.K_a] or keys[pygame.K_LEFT]:  
                self.player.move(-self.player_speed, 0)
            if keys[pygame.K_d] or keys[pygame.K_RIGHT]: 
                self.player.move(self.player_speed, 0)
            if keys[pygame.K_SPACE] or keys[pygame.K_w] or keys[pygame.K_UP]:
                self.player.should_shoot()

            for event in pygame.event.get():  
                if event.type == pygame.QUIT:  
                    return
            self.update_game_state()
            self.draw_game_state()
            self.level_end_sentinel.check_condition()
            time.sleep(0.1)

    def update_game_state(self):
        self.player.move(0, 0) 

        new_bullet = self.player.shoot()
        if new_bullet is not None:
            self.bullets.append(new_bullet)

        if self.aliens:
            rightmost_alien_x = max(alien.x for alien in self.aliens)
            leftmost_alien_x = min(alien.x for alien in self.aliens)
            if rightmost_alien_x + self.aliens[0].speed > 800 or leftmost_alien_x - self.aliens[0].speed < 0:
                self.alien_direction *= -1
                for alien in self.aliens:
                    alien.y += alien.down_speed
            for alien in self.aliens:
                alien.move(self.alien_direction)
                if alien.y >= self.player.y:
                    self.player.decrease_lives()

        for bullet in self.bullets:
            bullet.move()
            for alien in self.aliens:
                if bullet.collides_with(alien):
                    self.bullets.remove(bullet)
                    self.aliens.remove(alien)
                    break

    def draw_game_state(self):
        self.screen.fill((0, 0, 0)) 
        pygame.draw.rect(self.screen, (255, 255, 255), pygame.Rect(self.player.x, self.player.y, 50, 50))  
        for alien in self.aliens:
            pygame.draw.circle(self.screen, (0, 255, 0), (alien.x, alien.y), alien.radius)
        for bullet in self.bullets:
            pygame.draw.rect(self.screen, (255, 0, 0), pygame.Rect(bullet.x, bullet.y, bullet.width, bullet.height))
        pygame.display.flip()  

if __name__ == '__main__':
    try:
        game = G4M3()
        game.start_level()
        game.run()
    finally:
        pygame.quit()
```

```
#G4M3Object.py
# Game Object Class: This class will extend the Base Object and will be the parent class for all the actual game entities like Player, Alien, and Bullet.

from B453Object import B453Object

class G4M3Object(B453Object):
    def __init__(self, x, y):
        super().__init__(x, y)
```

```
#B453Object.py
# Base Object Class: This will be the parent class for all game objects. It will contain listeners and methods to add, remove, and trigger events.

class B453Object:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
        self.listeners = []

    def add_listener(self, listener):
        self.listeners.append(listener)

    def remove_listener(self, listener):
        self.listeners.remove(listener)

    def trigger_event(self, event):
        for listener in self.listeners:
            listener.handle_event(event)
```

```
#S3N71N3L.py
# Sentinel Class: This class extends the BaseObject class and acts as a trigger safety. It checks whether certain conditions are met before triggering its event.

from B453Object import B453Object

class S3N71N3L(B453Object):
    def __init__(self, player, aliens):
        super().__init__()
        self.player = player
        self.aliens = aliens

    def check_condition(self):
        # Check if Alien :codie_bug: has landed.
        if any(alien.has_reached_bottom() for alien in self.aliens):
            raise Exception("We have :codie_bug:'s!")
        # Check if all Alien :codie_bug:'s have been eliminated
        elif all(alien.all_aliens_eliminated() for alien in self.aliens):
            self.trigger_event('level_end')
        # Check if any Alien :codie_bug: has reached the player
        elif any(alien.y >= self.player.y for alien in self.aliens): 
            self.player.decrease_lives()
        # Check if Player has lost the base.
        elif self.player.all_your_base_r_belong_2_us():
            self.trigger_event('game_over')
```

```
#AL13N.py
# Alien Class:

from G4M3Object import G4M3Object

class AL13N(G4M3Object):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.radius = 20 
        self.direction = 1
        self.speed = 30
        self.down_speed = 10

    def move(self, direction):
        self.x += self.speed * direction

    def has_reached_bottom(self):
        return self.y > 600
    
    def all_aliens_eliminated(self):
        return self.y > 600
```

```
#BULL37.py
# Bullet Class:

from G4M3Object import G4M3Object

class BULL37(G4M3Object):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.width = 5
        self.height = 10

    def move(self):
        self.y -= 5

    def collides_with(self, alien):
        distance = ((self.x - alien.x)**2 + (self.y - alien.y)**2)**0.5
        return distance <= alien.radius
```

```
#PL4Y3R.py
# Player Class:

from G4M3Object import G4M3Object
from EN717135.BULL37 import BULL37

class PL4Y3R(G4M3Object):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.shoot_bullet = False
        self.lives = 3 

    def decrease_lives(self):
        self.lives -= 1
        if self.lives == 0:
            self.trigger_event('game_over')
        else:
            self.trigger_event('level_end')

    def move(self, dx, dy):
        self.x = (self.x + dx) % 800
        self.y = (self.y + dy) % 600

    def shoot(self):
        if self.shoot_bullet:
            self.shoot_bullet = False
            return BULL37(self.x, self.y)
        else:
            return None

    def should_shoot(self):
        self.shoot_bullet = True

    def all_your_base_r_belong_2_us(self):
        return self.x <= 0 or self.x >= 800
```